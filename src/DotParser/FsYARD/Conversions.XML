<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>Conversions</name></assembly>
<members>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Yard.Core.Conversions.AddDefaultAC.addAcToProduction(Microsoft.FSharp.Core.FSharpRef{Microsoft.FSharp.Collections.FSharpList{System.String}},Yard.Core.IL.Production.t{Yard.Core.IL.Source.t,Yard.Core.IL.Source.t})">
<summary>
 Adds action code to production considering it is used somewhere
</summary>
</member>
<member name="T:Yard.Core.Conversions.AddDefaultAC">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Conversions.AddEOF">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Conversions.BuildAST">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Yard.Core.Conversions.BuildAstSimple._buildAstSimple(System.String,Yard.Core.IL.Production.t{Yard.Core.IL.Source.t,Yard.Core.IL.Source.t})">
<summary>
 ruleName is empty when production is inner and action code returns list of nodes
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Conversions.BuildAstSimple">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Conversions.EliminateLeftRecursion">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Conversions.ExpandBrackets">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Conversions.ExpandEbnfStrict">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Conversions.ExpandInline">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Conversions.ExpandInnerAlt">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Yard.Core.Conversions.ExpandMeta.expandMeta(Yard.Core.IL.Production.t{Yard.Core.IL.Source.t,Yard.Core.IL.Source.t},System.String,System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.Tuple{System.String,Yard.Core.IL.Rule.t{Yard.Core.IL.Source.t,Yard.Core.IL.Source.t}}}},System.Collections.Generic.Dictionary{System.String,Yard.Core.IL.Production.t{Yard.Core.IL.Source.t,Yard.Core.IL.Source.t}})">
 <summary>
 <para> Replace rule with new one, replacing references to metarules, </para>
 <para> and generate new rules for every such reference </para>
 <para> body: t - production which can contain metareferences </para>
 <para> metaRules: TO_DO Dictionary&lt;string,Rule.t&lt;Source.t,Source.t&gt;&gt; - table, which contains expanding metareferences rules </para>
 <para> expanded: Dictionary&lt;string,Production.t&gt; - map of metareference with actual params to generated rule name </para>
 <para> res: Rule.t list - currently generated rules </para>
 <para> returns (new body, generated rules + old rules) </para>
 </summary>
</member>
<member name="M:Yard.Core.Conversions.ExpandMeta.findMetaRule(System.Collections.Generic.IDictionary{System.String,System.Collections.Generic.Dictionary{System.String,System.Tuple{System.String,Yard.Core.IL.Rule.t{Yard.Core.IL.Source.t,Yard.Core.IL.Source.t}}}},System.String,System.String)">
<summary>
 find metarule with given name in hash map of collected metarules
</summary>
</member>
<member name="T:Yard.Core.Conversions.ExpandMeta">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Conversions.ExpandTopLevelAlt">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Conversions.LeaveLast">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Conversions.Linearize">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Conversions.MergeAlter">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Conversions.RemoveAST">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Conversions.ReplaceLiterals">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Conversions.ToCNF">

</member>
<member name="">

</member>
<member name="M:Yard.Core.Conversions.TransformAux.list2opt``1(Microsoft.FSharp.Collections.FSharpList{``0})">
<summary>
 Create option from empty or one element list
</summary>
</member>
<member name="M:Yard.Core.Conversions.TransformAux.createParams(Microsoft.FSharp.Collections.FSharpList{Yard.Core.IL.Source.t})">
<summary>
 Reduce param list to string. Arguments are separated by spaces
</summary>
</member>
<member name="">

</member>
<member name="M:Yard.Core.Conversions.TransformAux.getNewSource(Yard.Core.IL.Source.t,System.String)">
<summary>
 Replace first (name) field in Source.t with new source 
</summary>
</member>
<member name="M:Yard.Core.Conversions.TransformAux.createSimpleRule``2(Yard.Core.IL.Source.t,Microsoft.FSharp.Collections.FSharpList{``0},Yard.Core.IL.Production.t{``0,``1})">
<summary>
 Non-start rule with empty meta-arguments list
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Conversions.TransformAux">

</member>
<member name="P:Yard.Core.Namer.getEofTokenName">
<summary>
 returns token name for EOF (End Of File)
</summary>
</member>
<member name="M:Yard.Core.Namer.createLiteralToken(System.Int32)">
<summary>
 returns token type for literal
</summary>
</member>
<member name="M:Yard.Core.Namer.createTknFileName(System.String)">
<summary>
 returns file name for tokens
</summary>
</member>
<member name="M:Yard.Core.Namer.createTypeName(System.String)">
<summary>
 type of semantic value
</summary>
</member>
<member name="M:Yard.Core.Namer.withTokenPrefix(System.String)">
<summary>
 token type (need for using bindings with tokens)
</summary>
</member>
<member name="M:Yard.Core.Namer.withElkPrefix(System.String)">
<summary>
 prefix for Elkhound bindings
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="M:Yard.Core.Namer.isItem(System.String)">
<summary>
 Does name have prefix &apos;item&apos;
</summary>
</member>
<member name="">

</member>
<member name="P:Yard.Core.Namer.getItem">
<summary>
 formal parameter name in metarules for EBNF clauses
</summary>
</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="">

</member>
<member name="T:Yard.Core.Namer.Names">

</member>
<member name="T:Yard.Core.Namer">

</member>
</members>
</doc>
