// Eugene Auduchinok, 2016

{
open DotParserProject.GraphData
open Option
open System.Collections.Generic
open System.Linq

let map = Map.ofList
let wrongEdge = failwithf "DotParser: unexpected token: %s"
}

tokens {
    _ of string
}

options {
    translate = true
    module = "DotParserProject.Gen.DotParser"
    infEpsPath = epsilons
    pos = uint64
}

module DotGrammar

[<Start>]
graph: g=graph_type [ID] LBRACE r=stmt_list<<g>> RBRACE { r }

graph_type: s=[STRICT] d=(GRAPH { false } | DIGRAPH { true }) { emptyGraph d (isSome s) }

stmt_list<<(g: GraphData)>>:
    g1=[s=stmt<<g>> [SEMI] s1=[stmt_list<<s>>] { if isSome s1 then s1.Value else s }] { if isSome g1 then g1.Value else g }

stmt<<(g: GraphData)>>:
    g1=node_stmt<<g>> { g1 }
  | g1=edge_stmt<<g>> { g1 }
  | g1=attr_stmt<<g>> { g1 }
  | g1=subgraph<<g>>  { fst g1 }


attr_stmt<<(g: GraphData)>>:
    k=(GRAPH { "graph" } | NODE { "node" } | EDGE { "edge" }) a=attr_list { addAttributes g k (map a) }

attr_list: LBRACK a=[a_list] RBRACK { if isSome a then a.Value else [] }

a_list: a=attr [SEMI { } | COMMA { }] l=[a_list] { if isSome l then a :: l.Value else [a] }

attr: k=ID ASSIGN v=ID { (k, v) }

node_stmt<<(g: GraphData)>>: n=ID a=[attr_list] { addNode g n (if isSome a then (map a.Value) else Map.empty) |> fst }

edge_stmt<<(g: GraphData)>>:
	n=nodes<<g>> g1=edge_rhs<<(fst n, [snd n])>> a=[attr_list] { addEdgesForList (fst g1) (snd g1) (if isSome a then (map a.Value) else Map.empty) }

edge_rhs<<(d: GraphData * string list list)>>:
    edgeop<<(fst d)>> n=nodes<<(fst d)>> r=[edge_rhs<<(fst n, (snd n) :: (snd d))>>] { if isSome r then r.Value else (fst n), ((snd n) :: (snd d)) }

nodes<<(g: GraphData)>>: n=node_id<<g>> { n } | n=subgraph<<g>> { n }
(* why n= ... {n} needed ? *)

edgeop<<(g: GraphData)>>:
	EDGE { if g.IsDirected then wrongEdge "--" else () }
  | DIEDGE { if not <| g.IsDirected then wrongEdge "->" else () }

node_id<<(g: GraphData)>>: name=ID { addNode g name Map.empty }

subgraph<<(g: GraphData)>>:
    [SUBGRAPH [ID] { }] LBRACE s=stmt_list<<(copyAttrs g)>> RBRACE { addSubgraph g s }