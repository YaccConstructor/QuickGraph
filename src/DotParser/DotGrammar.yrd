// Eugene Auduchinok, 2016

{
open DotParserProject.GraphData
open Option
open System.Collections.Generic
open System.Linq
open QuickGraph
}

tokens {
    _ of string
}

options {
    translate = true
    module = "DotParserProject.Gen.DotParser"
    infEpsPath = epsilons
    pos = uint64
}

module DotGrammar

[<Start>]
graph: g=graph_type [ID] LBRACE r=stmt_list<<g>> RBRACE { r }

graph_type: s=[STRICT] d=(GRAPH { false } | DIGRAPH { true }) { emptyGraph d (isSome s) }

stmt_list<<(g: GraphData)>>:
    g1=[s=stmt<<g>> [SEMI] s1=[stmt_list<<s>>] { if isSome s1 then s1.Value else s }] { if isSome g1 then g1.Value else g }

stmt<<(g: GraphData)>>:
    g1=node_stmt<<g>> { g1 }
  | g1=edge_stmt<<g>> { g1 }
  | g1=attr_stmt<<g>> { g1 }


attr_stmt<<(g: GraphData)>>:
    k=(GRAPH { "graph" } | NODE { "node" } | EDGE { "edge" }) a=attr_list { addAttributes g k (Map.ofList a) }

attr_list: LBRACK a=[a_list] RBRACK { if isSome a then a.Value else [] }

a_list: a=attr [SEMI { } | COMMA { }] l=[a_list] { if isSome l then a :: l.Value else [a] }
(* -SEMI | -COMMA doesn't work *)

attr: k=ID ASSIGN v=ID { (k, v) }

node_stmt<<(g: GraphData)>>: g1=node_id<<g>> { fst g1 }

edge_stmt<<(g: GraphData)>>: n=nodes<<g>> g1=edge_rhs<<(fst n, snd n)>> { fst g1 }

edge_rhs<<(d: GraphData * string list)>>:
    e=edgeop<<d>> r=[edge_rhs<<(fst e, snd e)>>] { if isSome r then r.Value else e }

nodes<<(g: GraphData)>>: n=node_id<<g>> { n } | n=subgraph<<g>> { n }
(* why n= ... {n} needed ? *)

edgeop<<(d: GraphData * string list)>>:
    (EDGE { } | DIEDGE { }) n=nodes<<(fst d)>> { addEdges (fst n) (snd d) (snd n) }

node_id<<(g: GraphData)>>: name=ID { addNode g name }

subgraph<<(g: GraphData)>>:
    [SUBGRAPH [ID] { }] LBRACE s=stmt_list<<(copyAttrs g)>> RBRACE { addSubgraph g s }